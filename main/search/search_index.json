{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>TODO: add badges</p>"},{"location":"#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>analora</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>analora</code> to a new version will possibly break any code that was using the old version of <code>analora</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>analora</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"refs/analyzer/","title":"Analyzer","text":""},{"location":"refs/analyzer/#analora.analyzer","title":"analora.analyzer","text":"<p>Contain analyzers.</p>"},{"location":"refs/analyzer/#analora.analyzer.AccuracyAnalyzer","title":"analora.analyzer.AccuracyAnalyzer","text":"<p>               Bases: <code>BaseTruePredAnalyzer</code></p> <p>Implement the accuracy analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>str</code> <p>The key of the ground truth target labels.</p> required <code>y_pred</code> <code>str</code> <p>The key of the predicted labels.</p> required <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing keys. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one key is missing. If <code>'warn'</code>, a warning is raised if at least one key is missing and the missing keys are ignored. If <code>'ignore'</code>, the missing keys are ignored and no warning message appears.</p> <code>'raise'</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.analyzer import AccuracyAnalyzer\n&gt;&gt;&gt; analyzer = AccuracyAnalyzer(y_true=\"target\", y_pred=\"pred\")\n&gt;&gt;&gt; analyzer\nAccuracyAnalyzer(y_true='target', y_pred='pred', missing_policy='raise', nan_policy='propagate')\n&gt;&gt;&gt; data = {\"pred\": [3, 2, 0, 1, 0, 1], \"target\": [3, 2, 0, 1, 0, 1]}\n&gt;&gt;&gt; output = analyzer.analyze(data)\n&gt;&gt;&gt; output\nOutput(\n  (content): ContentGenerator()\n  (evaluator): AccuracyEvaluator(\n      (state): AccuracyState(y_true=(6,), y_pred=(6,), y_true_name='target', y_pred_name='pred', nan_policy='propagate')\n    )\n)\n</code></pre>"},{"location":"refs/analyzer/#analora.analyzer.BaseAnalyzer","title":"analora.analyzer.BaseAnalyzer","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to analyze a DataFrame.</p> <p>Example usage:</p> <pre><code># &gt;&gt;&gt; import polars as pl\n# &gt;&gt;&gt; from analora.analyzer import AccuracyAnalyzer\n# &gt;&gt;&gt; analyzer = AccuracyAnalyzer(y_true=\"target\", y_pred=\"pred\")\n# &gt;&gt;&gt; analyzer\n# AccuracyAnalyzer(y_true='target', y_pred='pred', drop_nulls=True, missing_policy='raise', nan_policy='propagate')\n# &gt;&gt;&gt; data = pl.DataFrame({\"pred\": [3, 2, 0, 1, 0, 1], \"target\": [3, 2, 0, 1, 0, 1]})\n# &gt;&gt;&gt; output = analyzer.analyze(data)\n# &gt;&gt;&gt; output\n# AccuracyOutput(\n#   (state): AccuracyState(y_true=(6,), y_pred=(6,), y_true_name='target', y_pred_name='pred', nan_policy='propagate')\n# )\n</code></pre>"},{"location":"refs/analyzer/#analora.analyzer.BaseAnalyzer.analyze","title":"analora.analyzer.BaseAnalyzer.analyze  <code>abstractmethod</code>","text":"<pre><code>analyze(data: T, lazy: bool = True) -&gt; BaseOutput\n</code></pre> <p>Analyze the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to analyze.</p> required <code>lazy</code> <code>bool</code> <p>If <code>True</code>, it forces the computation of the output, otherwise it returns an output object that contains the logic.</p> <code>True</code> <p>Returns:</p> Type Description <code>BaseOutput</code> <p>The generated output.</p> <p>Example usage:</p> <pre><code># &gt;&gt;&gt; import polars as pl\n# &gt;&gt;&gt; from analora.analyzer import AccuracyAnalyzer\n# &gt;&gt;&gt; analyzer = AccuracyAnalyzer(y_true=\"target\", y_pred=\"pred\")\n# &gt;&gt;&gt; data = pl.DataFrame({\"pred\": [3, 2, 0, 1, 0, 1], \"target\": [3, 2, 0, 1, 0, 1]})\n# &gt;&gt;&gt; output = analyzer.analyze(data)\n# &gt;&gt;&gt; output\n# AccuracyOutput(\n#   (state): AccuracyState(y_true=(6,), y_pred=(6,), y_true_name='target', y_pred_name='pred', nan_policy='propagate')\n# )\n</code></pre>"},{"location":"refs/analyzer/#analora.analyzer.BaseLazyAnalyzer","title":"analora.analyzer.BaseLazyAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer[T]</code></p> <p>Define a base class to implement a lazy analyzer.</p> <p>Example usage:</p> <pre><code># &gt;&gt;&gt; import polars as pl\n# &gt;&gt;&gt; from analora.analyzer import SummaryAnalyzer\n# &gt;&gt;&gt; analyzer = SummaryAnalyzer()\n# &gt;&gt;&gt; analyzer\n# SummaryAnalyzer(columns=None, exclude_columns=(), missing_policy='raise', top=5)\n# &gt;&gt;&gt; frame = pl.DataFrame(\n# ...     {\n# ...         \"col1\": [0, 1, 1, 0, 0, 1, 0],\n# ...         \"col2\": [0, 1, 0, 1, 0, 1, 0],\n# ...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0],\n# ...     },\n# ...     schema={\"col1\": pl.Int64, \"col2\": pl.Int32, \"col3\": pl.Float64},\n# ... )\n# &gt;&gt;&gt; output = analyzer.analyze(frame)\n# &gt;&gt;&gt; output\n# SummaryOutput(\n#   (state): DataFrameState(dataframe=(7, 3), nan_policy='propagate', figure_config=MatplotlibFigureConfig(), top=5)\n# )\n</code></pre>"},{"location":"refs/analyzer/#analora.analyzer.BaseTruePredAnalyzer","title":"analora.analyzer.BaseTruePredAnalyzer","text":"<p>               Bases: <code>BaseLazyAnalyzer[T]</code></p> <p>Define a base class to implement a data analyzer that takes two input keys: <code>y_true</code> and <code>y_pred</code>.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>str</code> <p>The key name of the ground truth target labels.</p> required <code>y_pred</code> <code>str</code> <p>The key name of the predicted labels.</p> required <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing keys. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one key is missing. If <code>'warn'</code>, a warning is raised if at least one key is missing and the missing keys are ignored. If <code>'ignore'</code>, the missing keys are ignored and no warning message appears.</p> required <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> required"},{"location":"refs/analyzer/#analora.analyzer.ContentAnalyzer","title":"analora.analyzer.ContentAnalyzer","text":"<p>               Bases: <code>BaseLazyAnalyzer[Any]</code></p> <p>Implement an analyzer that generates an output with the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.analyzer import ContentAnalyzer\n&gt;&gt;&gt; analyzer = ContentAnalyzer(content=\"meow\")\n&gt;&gt;&gt; analyzer\nContentAnalyzer()\n&gt;&gt;&gt; data = {\"pred\": [3, 2, 0, 1, 0, 1], \"target\": [3, 2, 0, 1, 0, 1]}\n&gt;&gt;&gt; output = analyzer.analyze(data)\n&gt;&gt;&gt; output\nOutput(\n  (content): ContentGenerator()\n  (evaluator): Evaluator(count=0)\n)\n</code></pre>"},{"location":"refs/analyzer/#analora.analyzer.is_analyzer_config","title":"analora.analyzer.is_analyzer_config","text":"<pre><code>is_analyzer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseAnalyzer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseAnalyzer</code> object.</p> <p>Example usage:</p> <pre><code># &gt;&gt;&gt; from analora.analyzer import is_analyzer_config\n# &gt;&gt;&gt; is_analyzer_config({\"_target_\": \"analora.analyzer.AccuracyAnalyzer\"})\n# True\n</code></pre>"},{"location":"refs/analyzer/#analora.analyzer.setup_analyzer","title":"analora.analyzer.setup_analyzer","text":"<pre><code>setup_analyzer(\n    analyzer: BaseAnalyzer | dict,\n) -&gt; BaseAnalyzer\n</code></pre> <p>Set up an analyzer.</p> <p>The analyzer is instantiated from its configuration by using the <code>BaseAnalyzer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>An analyzer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseAnalyzer</code> <p>An instantiated analyzer.</p> <p>Example usage:</p> <pre><code># &gt;&gt;&gt; from analora.analyzer import setup_analyzer\n# &gt;&gt;&gt; analyzer = setup_analyzer(\n# ...     {\n# ...         \"_target_\": \"analora.analyzer.AccuracyAnalyzer\",\n# ...         \"y_true\": \"target\",\n# ...         \"y_pred\": \"pred\",\n# ...     }\n# ... )\n# &gt;&gt;&gt; analyzer\n# AccuracyAnalyzer(y_true='target', y_pred='pred', drop_nulls=True, missing_policy='raise', nan_policy='propagate')\n</code></pre>"},{"location":"refs/array/","title":"Array","text":""},{"location":"refs/array/#analora.array","title":"analora.array","text":"<p>Contain functions for <code>numpy.ndarray</code>s.</p>"},{"location":"refs/array/#analora.array.check_same_shape","title":"analora.array.check_same_shape","text":"<pre><code>check_same_shape(arrays: Iterable[ndarray]) -&gt; None\n</code></pre> <p>Check if arrays have the same shape.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Iterable[ndarray]</code> <p>The arrays to check.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the arrays have different shapes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import check_same_shape\n&gt;&gt;&gt; check_same_shape([np.array([1, 0, 0, 1]), np.array([0, 1, 0, 1])])\n</code></pre>"},{"location":"refs/array/#analora.array.check_square_matrix","title":"analora.array.check_square_matrix","text":"<pre><code>check_square_matrix(name: str, array: ndarray) -&gt; None\n</code></pre> <p>Check if the input array is a square matrix.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable.</p> required <code>array</code> <code>ndarray</code> <p>The array to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the array is not a square matrix.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import check_square_matrix\n&gt;&gt;&gt; check_square_matrix(\"var\", np.ones((3, 3)))\n</code></pre>"},{"location":"refs/array/#analora.array.filter_range","title":"analora.array.filter_range","text":"<pre><code>filter_range(\n    array: ndarray, xmin: float, xmax: float\n) -&gt; ndarray\n</code></pre> <p>Filter in the values in a given range.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <code>xmin</code> <code>float</code> <p>The lower bound of the range.</p> required <code>xmax</code> <code>float</code> <p>The upper bound of the range.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 1-d array with only the values in the given range.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import filter_range\n&gt;&gt;&gt; out = filter_range(np.arange(10), xmin=-1, xmax=5)\n&gt;&gt;&gt; out\narray([0, 1, 2, 3, 4, 5])\n</code></pre>"},{"location":"refs/array/#analora.array.find_range","title":"analora.array.find_range","text":"<pre><code>find_range(\n    values: ndarray,\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n) -&gt; tuple[float, float]\n</code></pre> <p>Find a valid range of value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>The values used to find the quantiles.</p> required <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The range of values in the format <code>(min, max)</code>. It returns <code>(nan, nan)</code> if the input array is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import find_range\n&gt;&gt;&gt; data = np.arange(101)\n&gt;&gt;&gt; find_range(data)\n(0, 100)\n&gt;&gt;&gt; find_range(data, xmin=5, xmax=50)\n(5, 50)\n&gt;&gt;&gt; find_range(data, xmin=\"q0.1\", xmax=\"q0.9\")\n(10.0, 90.0)\n</code></pre>"},{"location":"refs/array/#analora.array.multi_isnan","title":"analora.array.multi_isnan","text":"<pre><code>multi_isnan(arrays: Sequence[ndarray]) -&gt; ndarray\n</code></pre> <p>Test element-wise for NaN for all input arrays and return result as a boolean array.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[ndarray]</code> <p>The input arrays to test. All the arrays must have the same shape.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A boolean array. <code>True</code> where any array is NaN, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import multi_isnan\n&gt;&gt;&gt; mask = multi_isnan(\n...     [np.array([1, 0, 0, 1, float(\"nan\")]), np.array([1, float(\"nan\"), 0, 1, 1])]\n... )\n&gt;&gt;&gt; mask\narray([False,  True, False, False,  True])\n</code></pre>"},{"location":"refs/array/#analora.array.nonnan","title":"analora.array.nonnan","text":"<pre><code>nonnan(array: ndarray) -&gt; ndarray\n</code></pre> <p>Return the non-NaN values of an array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 1d array with the non-NaN values of the input array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import nonnan\n&gt;&gt;&gt; nonnan(np.asarray([1, 2, float(\"nan\"), 5, 6]))\narray([1., 2., 5., 6.])\n&gt;&gt;&gt; nonnan(np.asarray([[1, 2, float(\"nan\")], [4, 5, 6]]))\narray([1., 2., 4., 5., 6.])\n</code></pre>"},{"location":"refs/array/#analora.array.rand_replace","title":"analora.array.rand_replace","text":"<pre><code>rand_replace(\n    arr: ndarray,\n    value: Any,\n    prob: float = 0.5,\n    rng: Generator | None = None,\n) -&gt; ndarray\n</code></pre> <p>Return an array that contains the same values as the input array, excepts some values are replaced by <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The array with the original values.</p> required <code>value</code> <code>Any</code> <p>The value used to replace existing values.</p> required <code>prob</code> <code>float</code> <p>The probability of value replacement. If the value is <code>0.2</code>, it means each value as 20% chance to be replaced.</p> <code>0.5</code> <code>rng</code> <code>Generator | None</code> <p>The random number generator used to decide which values are replaced or not. If <code>None</code>, the default random number generator is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The generated array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.array import rand_replace\n&gt;&gt;&gt; rng = np.random.default_rng(42)\n&gt;&gt;&gt; out = rand_replace(np.arange(10), value=-1, prob=0.4, rng=rng)\n</code></pre>"},{"location":"refs/content/","title":"Content","text":""},{"location":"refs/content/#analora.content","title":"analora.content","text":"<p>Contain HTML content generators.</p>"},{"location":"refs/content/#analora.content.BaseContentGenerator","title":"analora.content.BaseContentGenerator","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a HTML Content Generator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; content = ContentGenerator(\"meow\")\n&gt;&gt;&gt; content\nContentGenerator()\n</code></pre>"},{"location":"refs/content/#analora.content.BaseContentGenerator.compute","title":"analora.content.BaseContentGenerator.compute  <code>abstractmethod</code>","text":"<pre><code>compute() -&gt; BaseContentGenerator\n</code></pre> <p>Compute the content and return a new content generator.</p> <p>Returns:</p> Type Description <code>BaseContentGenerator</code> <p>A new content generator with the computed content.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; content = ContentGenerator(\"meow\")\n&gt;&gt;&gt; content\nContentGenerator()\n&gt;&gt;&gt; content2 = content.compute()\n&gt;&gt;&gt; content2\nContentGenerator()\n</code></pre>"},{"location":"refs/content/#analora.content.BaseContentGenerator.equal","title":"analora.content.BaseContentGenerator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two content generators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other content generator to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two content generators are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; content1 = ContentGenerator(\"meow\")\n&gt;&gt;&gt; content2 = ContentGenerator(\"meow\")\n&gt;&gt;&gt; content3 = ContentGenerator(\"hello\")\n&gt;&gt;&gt; content1.equal(content2)\nTrue\n&gt;&gt;&gt; content1.equal(content3)\nFalse\n</code></pre>"},{"location":"refs/content/#analora.content.BaseContentGenerator.generate_body","title":"analora.content.BaseContentGenerator.generate_body  <code>abstractmethod</code>","text":"<pre><code>generate_body(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n) -&gt; str\n</code></pre> <p>Return the HTML body associated to the content.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number, if any.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the content section, if any.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the content section, if any.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML body associated to the content section.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; content = ContentGenerator(\"meow\")\n&gt;&gt;&gt; content.generate_body()\n</code></pre>"},{"location":"refs/content/#analora.content.BaseContentGenerator.generate_toc","title":"analora.content.BaseContentGenerator.generate_toc  <code>abstractmethod</code>","text":"<pre><code>generate_toc(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Return the HTML table of content (TOC) associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number associated to the section, if any.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section, if any.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report, if any.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to generate in the TOC.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML table of content associated to the section.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; content = ContentGenerator(\"meow\")\n&gt;&gt;&gt; content.generate_toc()\n</code></pre>"},{"location":"refs/content/#analora.content.BaseSectionContentGenerator","title":"analora.content.BaseSectionContentGenerator","text":"<p>               Bases: <code>BaseContentGenerator</code></p> <p>Define a base class to implement a section content generator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; generator = ContentGenerator(\"meow\")\n&gt;&gt;&gt; generator\nContentGenerator()\n&gt;&gt;&gt; generator.generate_content()\n'meow'\n</code></pre>"},{"location":"refs/content/#analora.content.BaseSectionContentGenerator.generate_content","title":"analora.content.BaseSectionContentGenerator.generate_content  <code>abstractmethod</code>","text":"<pre><code>generate_content() -&gt; str\n</code></pre> <p>Return the section content without the tags.</p> <p>Returns:</p> Type Description <code>str</code> <p>The content  without the tags.</p>"},{"location":"refs/content/#analora.content.ContentGenerator","title":"analora.content.ContentGenerator","text":"<p>               Bases: <code>BaseSectionContentGenerator</code></p> <p>Implement a section that analyze accuracy states.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The HTML content.</p> <code>''</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; generator = ContentGenerator(\"meow\")\n&gt;&gt;&gt; generator\nContentGenerator()\n&gt;&gt;&gt; generator.generate_content()\n'meow'\n</code></pre>"},{"location":"refs/evaluator/","title":"Evaluator","text":""},{"location":"refs/evaluator/#analora.evaluator","title":"analora.evaluator","text":"<p>Contain evaluators.</p>"},{"location":"refs/evaluator/#analora.evaluator.AccuracyEvaluator","title":"analora.evaluator.AccuracyEvaluator","text":"<p>               Bases: <code>BaseStateEvaluator[AccuracyState]</code></p> <p>Implement the accuracy evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AccuracyState</code> <p>The state containing the ground truth and predicted labels.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.evaluator import AccuracyEvaluator\n&gt;&gt;&gt; from analora.state import AccuracyState\n&gt;&gt;&gt; evaluator = AccuracyEvaluator(\n...     AccuracyState(\n...         y_true=np.array([1, 0, 0, 1, 1]),\n...         y_pred=np.array([1, 0, 0, 1, 1]),\n...         y_true_name=\"target\",\n...         y_pred_name=\"pred\",\n...     )\n... )\n&gt;&gt;&gt; evaluator\nAccuracyEvaluator(\n  (state): AccuracyState(y_true=(5,), y_pred=(5,), y_true_name='target', y_pred_name='pred', nan_policy='propagate')\n)\n&gt;&gt;&gt; evaluator.evaluate()\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/evaluator/#analora.evaluator.BaseEvaluator","title":"analora.evaluator.BaseEvaluator","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an evaluator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; evaluator = Evaluator({\"accuracy\": 1.0, \"total\": 42})\n&gt;&gt;&gt; evaluator\nEvaluator(count=2)\n&gt;&gt;&gt; evaluator.evaluate()\n{'accuracy': 1.0, 'total': 42}\n</code></pre>"},{"location":"refs/evaluator/#analora.evaluator.BaseEvaluator.compute","title":"analora.evaluator.BaseEvaluator.compute  <code>abstractmethod</code>","text":"<pre><code>compute() -&gt; BaseEvaluator\n</code></pre> <p>Compute the metrics and return a new evaluator.</p> <p>Returns:</p> Type Description <code>BaseEvaluator</code> <p>A new evaluator with the computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; evaluator = Evaluator({\"accuracy\": 1.0, \"total\": 42})\n&gt;&gt;&gt; evaluator2 = evaluator.compute()\n&gt;&gt;&gt; evaluator2\nEvaluator(count=2)\n</code></pre>"},{"location":"refs/evaluator/#analora.evaluator.BaseEvaluator.equal","title":"analora.evaluator.BaseEvaluator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two evaluators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other evaluator to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two evaluators are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; evaluator1 = Evaluator({\"accuracy\": 1.0, \"total\": 42})\n&gt;&gt;&gt; evaluator2 = Evaluator({\"accuracy\": 1.0, \"total\": 42})\n&gt;&gt;&gt; evaluator3 = Evaluator({\"accuracy\": 0.5, \"total\": 42})\n&gt;&gt;&gt; evaluator1.equal(evaluator2)\nTrue\n&gt;&gt;&gt; evaluator1.equal(evaluator3)\nFalse\n</code></pre>"},{"location":"refs/evaluator/#analora.evaluator.BaseEvaluator.evaluate","title":"analora.evaluator.BaseEvaluator.evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate(prefix: str = '', suffix: str = '') -&gt; dict\n</code></pre> <p>Evaluate the metrics.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>The metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; evaluator = Evaluator({\"accuracy\": 1.0, \"total\": 42})\n&gt;&gt;&gt; evaluator.evaluate()\n{'accuracy': 1.0, 'total': 42}\n</code></pre>"},{"location":"refs/evaluator/#analora.evaluator.BaseStateEvaluator","title":"analora.evaluator.BaseStateEvaluator","text":"<p>               Bases: <code>BaseEvaluator</code>, <code>Generic[T]</code></p> <p>Define the base class to implement evaluators that compute the metrics from a state object.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>T</code> <p>The state with the data.</p> required"},{"location":"refs/evaluator/#analora.evaluator.Evaluator","title":"analora.evaluator.Evaluator","text":"<p>               Bases: <code>BaseEvaluator</code></p> <p>Implement a simple evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>dict | None</code> <p>The dictionary of metrics.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; evaluator = Evaluator({\"accuracy\": 1.0, \"total\": 42})\n&gt;&gt;&gt; evaluator\nEvaluator(count=2)\n&gt;&gt;&gt; evaluator.evaluate()\n{'accuracy': 1.0, 'total': 42}\n</code></pre>"},{"location":"refs/ingestor/","title":"Ingestor","text":""},{"location":"refs/ingestor/#analora.ingestor","title":"analora.ingestor","text":"<p>Contain data ingestors.</p>"},{"location":"refs/ingestor/#analora.ingestor.BaseIngestor","title":"analora.ingestor.BaseIngestor","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a data ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor([1, 2, 3, 4])\n&gt;&gt;&gt; ingestor\nIngestor()\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.BaseIngestor.equal","title":"analora.ingestor.BaseIngestor.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two ingestor objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two ingestors are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import Ingestor\n&gt;&gt;&gt; obj1 = Ingestor([1, 2, 3, 4])\n&gt;&gt;&gt; obj2 = Ingestor([1, 2, 3, 4])\n&gt;&gt;&gt; obj3 = Ingestor([\"a\", \"b\", \"c\"])\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.BaseIngestor.ingest","title":"analora.ingestor.BaseIngestor.ingest  <code>abstractmethod</code>","text":"<pre><code>ingest() -&gt; T\n</code></pre> <p>Ingest data.</p> <p>Returns:</p> Type Description <code>T</code> <p>The ingested data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor([1, 2, 3, 4])\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.Ingestor","title":"analora.ingestor.Ingestor","text":"<p>               Bases: <code>BaseIngestor[T]</code></p> <p>Implement a simple data ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor(data=[1, 2, 3, 4, 5])\n&gt;&gt;&gt; ingestor\nIngestor()\n&gt;&gt;&gt; data = ingestor.ingest()\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.MappingIngestor","title":"analora.ingestor.MappingIngestor","text":"<p>               Bases: <code>BaseIngestor[dict[str, T]]</code></p> <p>Implement a simple data ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>ingestors</code> <code>Mapping[str, BaseIngestor[T] | dict]</code> <p>The mapping of ingestors or their configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import Ingestor, MappingIngestor\n&gt;&gt;&gt; ingestor = MappingIngestor(\n...     {\"key1\": Ingestor(data=[1, 2, 3, 4, 5]), \"key2\": Ingestor(data=\"meow\")}\n... )\n&gt;&gt;&gt; ingestor\nMappingIngestor(\n  (key1): Ingestor()\n  (key2): Ingestor()\n)\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\n{'key1': [1, 2, 3, 4, 5], 'key2': 'meow'}\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.PickleIngestor","title":"analora.ingestor.PickleIngestor","text":"<p>               Bases: <code>BaseIngestor[Any]</code></p> <p>Implement a pickle file ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the pickle file containing the data to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import PickleIngestor\n&gt;&gt;&gt; ingestor = PickleIngestor(path=\"/path/to/data.pickle\")\n&gt;&gt;&gt; ingestor\nPickleIngestor(path=/path/to/data.pickle)\n&gt;&gt;&gt; data = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.TorchIngestor","title":"analora.ingestor.TorchIngestor","text":"<p>               Bases: <code>BaseIngestor[Any]</code></p> <p>Implement a torch file ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the torch file containing the data to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>torch.load</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import TorchIngestor\n&gt;&gt;&gt; ingestor = TorchIngestor(path=\"/path/to/data.pt\")\n&gt;&gt;&gt; ingestor\nTorchIngestor(path=/path/to/data.pt)\n&gt;&gt;&gt; data = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.is_ingestor_config","title":"analora.ingestor.is_ingestor_config","text":"<pre><code>is_ingestor_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseIngestor</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseIngestor</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import is_ingestor_config\n&gt;&gt;&gt; is_ingestor_config({\"_target_\": \"analora.ingestor.Ingestor\", \"data\": [1, 2, 3, 4]})\nTrue\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.setup_ingestor","title":"analora.ingestor.setup_ingestor","text":"<pre><code>setup_ingestor(\n    ingestor: BaseIngestor | dict,\n) -&gt; BaseIngestor\n</code></pre> <p>Set up an ingestor.</p> <p>The ingestor is instantiated from its configuration by using the <code>BaseIngestor</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>An ingestor or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseIngestor</code> <p>An instantiated ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor import setup_ingestor\n&gt;&gt;&gt; ingestor = setup_ingestor(\n...     {\"_target_\": \"analora.ingestor.Ingestor\", \"data\": [1, 2, 3, 4]}\n... )\n&gt;&gt;&gt; ingestor\nIngestor()\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.polars","title":"analora.ingestor.polars","text":"<p>Contain polars DataFrame ingestors.</p>"},{"location":"refs/ingestor/#analora.ingestor.polars.CsvIngestor","title":"analora.ingestor.polars.CsvIngestor","text":"<p>               Bases: <code>BaseIngestor[DataFrame]</code></p> <p>Implement a CSV ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>The source to the CSV data to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.scan_csv</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor.polars import CsvIngestor\n&gt;&gt;&gt; ingestor = CsvIngestor(source=\"/path/to/frame.csv\")\n&gt;&gt;&gt; ingestor\nCsvIngestor(source=/path/to/frame.csv)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#analora.ingestor.polars.ParquetIngestor","title":"analora.ingestor.polars.ParquetIngestor","text":"<p>               Bases: <code>BaseIngestor[DataFrame]</code></p> <p>Implement a parquet ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>The source to the parquet data to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.read_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.ingestor.polars import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(source=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(source=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/metric/","title":"Metric","text":""},{"location":"refs/metric/#analora.metric","title":"analora.metric","text":"<p>Contain functions to compute metrics.</p>"},{"location":"refs/metric/#analora.metric.accuracy","title":"analora.metric.accuracy","text":"<pre><code>accuracy(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import accuracy\n&gt;&gt;&gt; accuracy(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.average_precision","title":"analora.metric.average_precision","text":"<pre><code>average_precision(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the average precision metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import average_precision\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; metrics = average_precision(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_score=np.array([2, -1, 0, 3, 1])\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': 1.0, 'count': 5}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; metrics = average_precision(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_score=np.array([2, -1, 0, 3, 1]),\n...     label_type=\"binary\",\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': 1.0, 'count': 5}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; metrics = average_precision(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_score=np.array(\n...         [\n...             [0.7, 0.2, 0.1],\n...             [0.4, 0.3, 0.3],\n...             [0.1, 0.8, 0.1],\n...             [0.2, 0.3, 0.5],\n...             [0.4, 0.4, 0.2],\n...             [0.1, 0.2, 0.7],\n...         ]\n...     ),\n...     label_type=\"multiclass\",\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': array([0.833..., 0.75 , 0.75 ]),\n 'count': 6,\n 'macro_average_precision': 0.777...,\n 'micro_average_precision': 0.75,\n 'weighted_average_precision': 0.777...}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; metrics = average_precision(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_score=np.array([[2, -1, -1], [-1, 1, 2], [0, 2, 3], [3, -2, -4], [1, -3, -5]]),\n...     label_type=\"multilabel\",\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': array([1. , 1. , 0.477...]),\n 'count': 5,\n 'macro_average_precision': 0.825...,\n 'micro_average_precision': 0.588...,\n 'weighted_average_precision': 0.804...}\n</code></pre>"},{"location":"refs/metric/#analora.metric.balanced_accuracy","title":"analora.metric.balanced_accuracy","text":"<pre><code>balanced_accuracy(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import balanced_accuracy\n&gt;&gt;&gt; balanced_accuracy(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'balanced_accuracy': 1.0, 'count': 5}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_average_precision","title":"analora.metric.binary_average_precision","text":"<pre><code>binary_average_precision(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the average precision metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples, *)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, *)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import binary_average_precision\n&gt;&gt;&gt; metrics = binary_average_precision(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_score=np.array([2, -1, 0, 3, 1])\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': 1.0, 'count': 5}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_confusion_matrix","title":"analora.metric.binary_confusion_matrix","text":"<pre><code>binary_confusion_matrix(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the confusion matrix metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import binary_confusion_matrix\n&gt;&gt;&gt; binary_confusion_matrix(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n{'confusion_matrix': array([[2, 0], [0, 3]]),\n 'count': 5,\n 'false_negative_rate': 0.0,\n 'false_negative': 0,\n 'false_positive_rate': 0.0,\n 'false_positive': 0,\n 'true_negative_rate': 1.0,\n 'true_negative': 2,\n 'true_positive_rate': 1.0,\n 'true_positive': 3}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_fbeta_score","title":"analora.metric.binary_fbeta_score","text":"<pre><code>binary_fbeta_score(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    betas: Sequence[float] = (1,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the F-beta metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>betas</code> <code>Sequence[float]</code> <p>The betas used to compute the F-beta scores.</p> <code>(1,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import binary_fbeta_score\n&gt;&gt;&gt; binary_fbeta_score(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n... )\n{'count': 5, 'f1': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_jaccard","title":"analora.metric.binary_jaccard","text":"<pre><code>binary_jaccard(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Jaccard metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import binary_jaccard\n&gt;&gt;&gt; binary_jaccard(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'jaccard': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_precision","title":"analora.metric.binary_precision","text":"<pre><code>binary_precision(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the precision metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import binary_precision\n&gt;&gt;&gt; binary_precision(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'precision': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_recall","title":"analora.metric.binary_recall","text":"<pre><code>binary_recall(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the recall metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import binary_recall\n&gt;&gt;&gt; binary_recall(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'recall': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.binary_roc_auc","title":"analora.metric.binary_roc_auc","text":"<pre><code>binary_roc_auc(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Area Under the Receiver Operating Characteristic Curve (ROC AUC) metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p>"},{"location":"refs/metric/#analora.metric.binary_top_k_accuracy","title":"analora.metric.binary_top_k_accuracy","text":"<pre><code>binary_top_k_accuracy(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    k: Sequence[int] = (2,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Area Under the Top-k Accuracy classification metrics for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>k</code> <code>Sequence[int]</code> <p>The numbers of most likely outcomes considered to find the correct label.</p> <code>(2,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p>"},{"location":"refs/metric/#analora.metric.confusion_matrix","title":"analora.metric.confusion_matrix","text":"<pre><code>confusion_matrix(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the confusion matrix metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import confusion_matrix\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; confusion_matrix(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'confusion_matrix': array([[2, 0], [0, 3]]),\n 'count': 5,\n 'false_negative_rate': 0.0,\n 'false_negative': 0,\n 'false_positive_rate': 0.0,\n 'false_positive': 0,\n 'true_negative_rate': 1.0,\n 'true_negative': 2,\n 'true_positive_rate': 1.0,\n 'true_positive': 3}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; confusion_matrix(\n...     y_true=np.array([0, 1, 1, 2, 2, 2]),\n...     y_pred=np.array([0, 1, 1, 2, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'confusion_matrix': array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]), 'count': 6}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; confusion_matrix(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'confusion_matrix': array([[[2, 0], [0, 3]],\n                            [[3, 0], [0, 2]],\n                            [[2, 0], [0, 3]]]),\n 'count': 5}\n</code></pre>"},{"location":"refs/metric/#analora.metric.energy_distance","title":"analora.metric.energy_distance","text":"<pre><code>energy_distance(\n    u_values: ndarray,\n    v_values: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the energy distance between two 1D distributions.</p> <p>Parameters:</p> Name Type Description Default <code>u_values</code> <code>ndarray</code> <p>The values observed in the (empirical) distribution.</p> required <code>v_values</code> <code>ndarray</code> <p>The values observed in the (empirical) distribution.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import energy_distance\n&gt;&gt;&gt; energy_distance(u_values=np.array([1, 2, 3, 4, 5]), v_values=np.array([1, 2, 3, 4, 5]))\n{'count': 5, 'energy_distance': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.fbeta_score","title":"analora.metric.fbeta_score","text":"<pre><code>fbeta_score(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    betas: Sequence[float] = (1,),\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the F-beta metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>betas</code> <code>Sequence[float]</code> <p>The betas used to compute the F-beta scores.</p> <code>(1,)</code> <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import fbeta_score\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; fbeta_score(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'f1': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; fbeta_score(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'count': 5, 'f1': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; fbeta_score(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'count': 6,\n 'f1': array([1., 1., 1.]),\n 'macro_f1': 1.0,\n 'micro_f1': 1.0,\n 'weighted_f1': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; fbeta_score(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'count': 5,\n 'f1': array([1., 1., 1.]),\n 'macro_f1': 1.0,\n 'micro_f1': 1.0,\n 'weighted_f1': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.jaccard","title":"analora.metric.jaccard","text":"<pre><code>jaccard(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Jaccard metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import jaccard\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; jaccard(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'jaccard': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; jaccard(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'count': 5, 'jaccard': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; jaccard(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'count': 6,\n 'jaccard': array([1., 1., 1.]),\n 'macro_jaccard': 1.0,\n 'micro_jaccard': 1.0,\n 'weighted_jaccard': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; jaccard(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'count': 5,\n 'jaccard': array([1., 1., 1.]),\n 'macro_jaccard': 1.0,\n 'micro_jaccard': 1.0,\n 'weighted_jaccard': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.jensen_shannon_divergence","title":"analora.metric.jensen_shannon_divergence","text":"<pre><code>jensen_shannon_divergence(\n    p: ndarray,\n    q: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Jensen-Shannon (JS) divergence between two distributions.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>ndarray</code> <p>The true probability distribution.</p> required <code>q</code> <code>ndarray</code> <p>The model probability distribution.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import jensen_shannon_divergence\n&gt;&gt;&gt; jensen_shannon_divergence(\n...     p=np.array([0.1, 0.6, 0.1, 0.2]), q=np.array([0.2, 0.5, 0.2, 0.1])\n... )\n{'size': 4, 'jensen_shannon_divergence': 0.027...}\n</code></pre>"},{"location":"refs/metric/#analora.metric.kl_div","title":"analora.metric.kl_div","text":"<pre><code>kl_div(\n    p: ndarray,\n    q: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Kullback-Leibler (KL) divergence between two distributions.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>ndarray</code> <p>The true probability distribution.</p> required <code>q</code> <code>ndarray</code> <p>The model probability distribution.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import kl_div\n&gt;&gt;&gt; kl_div(p=np.array([0.1, 0.6, 0.1, 0.2]), q=np.array([0.2, 0.5, 0.2, 0.1]))\n{'size': 4, 'kl_pq': 0.109..., 'kl_qp': 0.116...}\n</code></pre>"},{"location":"refs/metric/#analora.metric.mean_absolute_error","title":"analora.metric.mean_absolute_error","text":"<pre><code>mean_absolute_error(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the mean absolute error (MAE).</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import mean_absolute_error\n&gt;&gt;&gt; mean_absolute_error(y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5]))\n{'count': 5, 'mean_absolute_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.mean_absolute_percentage_error","title":"analora.metric.mean_absolute_percentage_error","text":"<pre><code>mean_absolute_percentage_error(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the mean absolute percentage error (MAPE).</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import mean_absolute_percentage_error\n&gt;&gt;&gt; mean_absolute_percentage_error(\n...     y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5])\n... )\n{'count': 5, 'mean_absolute_percentage_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.mean_squared_error","title":"analora.metric.mean_squared_error","text":"<pre><code>mean_squared_error(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the mean squared error (MSE).</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import mean_squared_error\n&gt;&gt;&gt; mean_squared_error(y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5]))\n{'count': 5, 'mean_squared_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.mean_squared_log_error","title":"analora.metric.mean_squared_log_error","text":"<pre><code>mean_squared_log_error(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the mean squared logarithmic error (MSLE).</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import mean_squared_log_error\n&gt;&gt;&gt; mean_squared_log_error(\n...     y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5])\n... )\n{'count': 5, 'mean_squared_log_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.mean_tweedie_deviance","title":"analora.metric.mean_tweedie_deviance","text":"<pre><code>mean_tweedie_deviance(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    powers: Sequence[float] = (0,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the mean Tweedie deviance regression loss.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>powers</code> <code>Sequence[float]</code> <p>The Tweedie power parameter. The higher power the less weight is given to extreme deviations between true and predicted targets.</p> <code>(0,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import mean_tweedie_deviance\n&gt;&gt;&gt; mean_tweedie_deviance(\n...     y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5])\n... )\n{'count': 5, 'mean_tweedie_deviance_power_0': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.median_absolute_error","title":"analora.metric.median_absolute_error","text":"<pre><code>median_absolute_error(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the median absolute error.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import median_absolute_error\n&gt;&gt;&gt; median_absolute_error(\n...     y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5])\n... )\n{'count': 5, 'median_absolute_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_average_precision","title":"analora.metric.multiclass_average_precision","text":"<pre><code>multiclass_average_precision(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the average precision metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multiclass_average_precision\n&gt;&gt;&gt; metrics = multiclass_average_precision(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_score=np.array(\n...         [\n...             [0.7, 0.2, 0.1],\n...             [0.4, 0.3, 0.3],\n...             [0.1, 0.8, 0.1],\n...             [0.2, 0.3, 0.5],\n...             [0.4, 0.4, 0.2],\n...             [0.1, 0.2, 0.7],\n...         ]\n...     ),\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': array([0.833..., 0.75 , 0.75 ]),\n 'count': 6,\n 'macro_average_precision': 0.777...,\n 'micro_average_precision': 0.75,\n 'weighted_average_precision': 0.777...}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_confusion_matrix","title":"analora.metric.multiclass_confusion_matrix","text":"<pre><code>multiclass_confusion_matrix(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the confusion matrix metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multiclass_confusion_matrix\n&gt;&gt;&gt; multiclass_confusion_matrix(\n...     y_true=np.array([0, 1, 1, 2, 2, 2]), y_pred=np.array([0, 1, 1, 2, 2, 2])\n... )\n{'confusion_matrix': array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]), 'count': 6}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_fbeta_score","title":"analora.metric.multiclass_fbeta_score","text":"<pre><code>multiclass_fbeta_score(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    betas: Sequence[float] = (1,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the F-beta metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>betas</code> <code>Sequence[float]</code> <p>The betas used to compute the F-beta scores.</p> <code>(1,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multiclass_fbeta_score\n&gt;&gt;&gt; multiclass_fbeta_score(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n... )\n{'count': 6,\n 'f1': array([1., 1., 1.]),\n 'macro_f1': 1.0,\n 'micro_f1': 1.0,\n 'weighted_f1': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_jaccard","title":"analora.metric.multiclass_jaccard","text":"<pre><code>multiclass_jaccard(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Jaccard metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multiclass_jaccard\n&gt;&gt;&gt; multiclass_jaccard(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]), y_pred=np.array([0, 0, 1, 1, 2, 2])\n... )\n{'count': 6,\n 'jaccard': array([1., 1., 1.]),\n 'macro_jaccard': 1.0,\n 'micro_jaccard': 1.0,\n 'weighted_jaccard': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_precision","title":"analora.metric.multiclass_precision","text":"<pre><code>multiclass_precision(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the precision metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multiclass_precision\n&gt;&gt;&gt; multiclass_precision(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]), y_pred=np.array([0, 0, 1, 1, 2, 2])\n... )\n{'count': 6,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_recall","title":"analora.metric.multiclass_recall","text":"<pre><code>multiclass_recall(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the recall metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multiclass_recall\n&gt;&gt;&gt; multiclass_recall(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]), y_pred=np.array([0, 0, 1, 1, 2, 2])\n... )\n{'count': 6,\n 'macro_recall': 1.0,\n 'micro_recall': 1.0,\n 'recall': array([1., 1., 1.]),\n 'weighted_recall': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multiclass_roc_auc","title":"analora.metric.multiclass_roc_auc","text":"<pre><code>multiclass_roc_auc(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Area Under the Receiver Operating Characteristic Curve (ROC AUC) metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p>"},{"location":"refs/metric/#analora.metric.multiclass_top_k_accuracy","title":"analora.metric.multiclass_top_k_accuracy","text":"<pre><code>multiclass_top_k_accuracy(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    k: Sequence[int] = (2,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Area Under the Top-k Accuracy classification metrics for multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>k</code> <code>Sequence[int]</code> <p>The numbers of most likely outcomes considered to find the correct label.</p> <code>(2,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p>"},{"location":"refs/metric/#analora.metric.multilabel_average_precision","title":"analora.metric.multilabel_average_precision","text":"<pre><code>multilabel_average_precision(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the average precision metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multilabel_average_precision\n&gt;&gt;&gt; metrics = multilabel_average_precision(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_score=np.array([[2, -1, -1], [-1, 1, 2], [0, 2, 3], [3, -2, -4], [1, -3, -5]]),\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': array([1. , 1. , 0.477...]),\n 'count': 5,\n 'macro_average_precision': 0.825...,\n 'micro_average_precision': 0.588...,\n 'weighted_average_precision': 0.804...}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multilabel_confusion_matrix","title":"analora.metric.multilabel_confusion_matrix","text":"<pre><code>multilabel_confusion_matrix(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the confusion matrix metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multilabel_confusion_matrix\n&gt;&gt;&gt; multilabel_confusion_matrix(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n... )\n{'confusion_matrix': array([[[2, 0], [0, 3]],\n                            [[3, 0], [0, 2]],\n                            [[2, 0], [0, 3]]]),\n 'count': 5}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multilabel_fbeta_score","title":"analora.metric.multilabel_fbeta_score","text":"<pre><code>multilabel_fbeta_score(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    betas: Sequence[float] = (1,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the F-beta metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>betas</code> <code>Sequence[float]</code> <p>The betas used to compute the F-beta scores.</p> <code>(1,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multilabel_fbeta_score\n&gt;&gt;&gt; multilabel_fbeta_score(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n... )\n{'count': 5,\n 'f1': array([1., 1., 1.]),\n 'macro_f1': 1.0,\n 'micro_f1': 1.0,\n 'weighted_f1': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multilabel_jaccard","title":"analora.metric.multilabel_jaccard","text":"<pre><code>multilabel_jaccard(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Jaccard metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multilabel_jaccard\n&gt;&gt;&gt; multilabel_jaccard(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n... )\n{'count': 5,\n 'jaccard': array([1., 1., 1.]),\n 'macro_jaccard': 1.0,\n 'micro_jaccard': 1.0,\n 'weighted_jaccard': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multilabel_precision","title":"analora.metric.multilabel_precision","text":"<pre><code>multilabel_precision(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the precision metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multilabel_precision\n&gt;&gt;&gt; multilabel_precision(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n... )\n{'count': 5,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multilabel_recall","title":"analora.metric.multilabel_recall","text":"<pre><code>multilabel_recall(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the recall metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import multilabel_recall\n&gt;&gt;&gt; multilabel_recall(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n... )\n{'count': 5,\n 'macro_recall': 1.0,\n 'micro_recall': 1.0,\n 'recall': array([1., 1., 1.]),\n 'weighted_recall': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.multilabel_roc_auc","title":"analora.metric.multilabel_roc_auc","text":"<pre><code>multilabel_roc_auc(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Area Under the Receiver Operating Characteristic Curve (ROC AUC) metrics for multilabel labels.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, n_classes)</code>.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p>"},{"location":"refs/metric/#analora.metric.ndcg","title":"analora.metric.ndcg","text":"<pre><code>ndcg(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    k: int | None = None,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Normalized Discounted Cumulative Gain (NDCG) metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target targets of multilabel classification, or true scores of entities to be ranked. Negative values in y_true may result in an output that is not between 0 and 1. This input must be an array of shape <code>(n_samples, n_labels)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The predicted scores, can either be probability estimates, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples, n_labels)</code>.</p> required <code>k</code> <code>int | None</code> <p>Only consider the highest <code>k</code> scores in the ranking. If <code>None</code>, use all outputs.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import ndcg\n&gt;&gt;&gt; ndcg(\n...     y_true=np.array([[1, 0, 0], [1, 2, 0], [1, 1, 2], [0, 0, 1]]),\n...     y_score=np.array(\n...         [[2.0, 1.0, 0.0], [0.0, 1.0, -1.0], [0.0, 0.0, 1.0], [1.0, 2.0, 3.0]]\n...     ),\n... )\n{'count': 4, 'ndcg': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.pearsonr","title":"analora.metric.pearsonr","text":"<pre><code>pearsonr(\n    x: ndarray,\n    y: ndarray,\n    *,\n    alternative: str = \"two-sided\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Pearson correlation coefficient and p-value for testing non-correlation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The first input array.</p> required <code>y</code> <code>ndarray</code> <p>The second input array.</p> required <code>alternative</code> <code>str</code> <p>The alternative hypothesis. Default is 'two-sided'. The following options are available: - 'two-sided': the correlation is nonzero - 'less': the correlation is negative (less than zero) - 'greater': the correlation is positive (greater than zero)</p> <code>'two-sided'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import pearsonr\n&gt;&gt;&gt; pearsonr(x=np.array([1, 2, 3, 4, 5]), y=np.array([1, 2, 3, 4, 5]))\n{'count': 5, 'pearson_coeff': 1.0, 'pearson_pvalue': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.precision","title":"analora.metric.precision","text":"<pre><code>precision(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the precision metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import precision\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; precision(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; precision(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; precision(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'count': 6,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; precision(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'count': 5,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.r2_score","title":"analora.metric.r2_score","text":"<pre><code>r2_score(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the R^2 (coefficient of determination) regression score metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import r2_score\n&gt;&gt;&gt; r2_score(y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5]))\n{'count': 5, 'r2_score': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.recall","title":"analora.metric.recall","text":"<pre><code>recall(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the recall metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import recall\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; recall(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'recall': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; recall(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'count': 5, 'recall': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; recall(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'count': 6,\n 'macro_recall': 1.0,\n 'micro_recall': 1.0,\n 'recall': array([1., 1., 1.]),\n 'weighted_recall': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; recall(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'count': 5,\n 'macro_recall': 1.0,\n 'micro_recall': 1.0,\n 'recall': array([1., 1., 1.]),\n 'weighted_recall': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.regression_errors","title":"analora.metric.regression_errors","text":"<pre><code>regression_errors(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the regression error metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import regression_errors\n&gt;&gt;&gt; regression_errors(y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5]))\n{'count': 5,\n 'mean_absolute_error': 0.0,\n 'median_absolute_error': 0.0,\n 'mean_squared_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.roc_auc","title":"analora.metric.roc_auc","text":"<pre><code>roc_auc(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Area Under the Receiver Operating Characteristic Curve (ROC AUC) metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import roc_auc\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; metrics = roc_auc(y_true=np.array([1, 0, 0, 1, 1]), y_score=np.array([2, -1, 0, 3, 1]))\n&gt;&gt;&gt; metrics\n{'count': 5, 'roc_auc': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; metrics = roc_auc(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_score=np.array([2, -1, 0, 3, 1]),\n...     label_type=\"binary\",\n... )\n&gt;&gt;&gt; metrics\n{'count': 5, 'roc_auc': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; metrics = roc_auc(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_score=np.array(\n...         [\n...             [0.7, 0.2, 0.1],\n...             [0.4, 0.3, 0.3],\n...             [0.1, 0.8, 0.1],\n...             [0.2, 0.3, 0.5],\n...             [0.4, 0.4, 0.2],\n...             [0.1, 0.2, 0.7],\n...         ]\n...     ),\n...     label_type=\"multiclass\",\n... )\n&gt;&gt;&gt; metrics\n{'count': 6,\n 'macro_roc_auc': 0.833...,\n 'micro_roc_auc': 0.826...,\n 'roc_auc': array([0.9375, 0.8125, 0.75  ]),\n 'weighted_roc_auc': 0.833...}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; metrics = roc_auc(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_score=np.array([[2, -1, -1], [-1, 1, 2], [0, 2, 3], [3, -2, -4], [1, -3, -5]]),\n...     label_type=\"multilabel\",\n... )\n&gt;&gt;&gt; metrics\n{'count': 5,\n 'macro_roc_auc': 0.666...,\n 'micro_roc_auc': 0.544...,\n 'roc_auc': array([1., 1., 0.]),\n 'weighted_roc_auc': 0.625}\n</code></pre>"},{"location":"refs/metric/#analora.metric.root_mean_squared_error","title":"analora.metric.root_mean_squared_error","text":"<pre><code>root_mean_squared_error(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the root mean squared error (RMSE).</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted values.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import root_mean_squared_error\n&gt;&gt;&gt; root_mean_squared_error(\n...     y_true=np.array([1, 2, 3, 4, 5]), y_pred=np.array([1, 2, 3, 4, 5])\n... )\n{'count': 5, 'root_mean_squared_error': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.spearmanr","title":"analora.metric.spearmanr","text":"<pre><code>spearmanr(\n    x: ndarray,\n    y: ndarray,\n    *,\n    alternative: str = \"two-sided\",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Spearman correlation coefficient and p-value for testing non-correlation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The first input array.</p> required <code>y</code> <code>ndarray</code> <p>The second input array.</p> required <code>alternative</code> <code>str</code> <p>The alternative hypothesis. Default is 'two-sided'. The following options are available: - 'two-sided': the correlation is nonzero - 'less': the correlation is negative (less than zero) - 'greater': the correlation is positive (greater than zero)</p> <code>'two-sided'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import spearmanr\n&gt;&gt;&gt; spearmanr(\n...     x=np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n...     y=np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n... )\n{'count': 9, 'spearman_coeff': 1.0, 'spearman_pvalue': 0.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.top_k_accuracy","title":"analora.metric.top_k_accuracy","text":"<pre><code>top_k_accuracy(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    k: Sequence[int] = (2,),\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float | ndarray]\n</code></pre> <p>Return the Area Under the Top-k Accuracy classification metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. The binary case expects scores with shape <code>(n_samples,)</code> while the multiclass case expects scores with shape <code>(n_samples, n_classes)</code>.</p> required <code>k</code> <code>Sequence[int]</code> <p>The numbers of most likely outcomes considered to find the correct label.</p> <code>(2,)</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float | ndarray]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import top_k_accuracy\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; metrics = top_k_accuracy(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_score=np.array([2, -1, 0, 3, 1]), k=[1, 2]\n... )\n&gt;&gt;&gt; metrics\n{'count': 5, 'top_1_accuracy': 1.0, 'top_2_accuracy': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; metrics = top_k_accuracy(\n...     y_true=np.array([0, 1, 2, 2]),\n...     y_score=np.array(\n...         [[0.5, 0.2, 0.2], [0.3, 0.4, 0.2], [0.2, 0.4, 0.3], [0.7, 0.2, 0.1]]\n...     ),\n...     k=[1, 2, 3],\n... )\n&gt;&gt;&gt; metrics\n{'count': 4, 'top_1_accuracy': 0.5, 'top_2_accuracy': 0.75, 'top_3_accuracy': 1.0}\n</code></pre>"},{"location":"refs/metric/#analora.metric.wasserstein_distance","title":"analora.metric.wasserstein_distance","text":"<pre><code>wasserstein_distance(\n    u_values: ndarray,\n    v_values: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    nan_policy: str = \"propagate\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the Wasserstein distance between two 1D discrete distributions.</p> <p>Parameters:</p> Name Type Description Default <code>u_values</code> <code>ndarray</code> <p>An array that contains a sample from a probability distribution or the support (set of all possible values) of a probability distribution. Each element is an observation or possible value.</p> required <code>v_values</code> <code>ndarray</code> <p>An array that contains a sample from or the support of a second distribution.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.metric import wasserstein_distance\n&gt;&gt;&gt; wasserstein_distance(\n...     u_values=np.array([1, 2, 3, 4, 5]), v_values=np.array([1, 2, 3, 4, 5])\n... )\n{'count': 5, 'wasserstein_distance': 0.0}\n</code></pre>"},{"location":"refs/output/","title":"Output","text":""},{"location":"refs/output/#analora.output","title":"analora.output","text":"<p>Contain outputs.</p>"},{"location":"refs/output/#analora.output.BaseLazyOutput","title":"analora.output.BaseLazyOutput","text":"<p>               Bases: <code>BaseOutput</code></p> <p>Define a base class that partially implements the lazy computation logic.</p>"},{"location":"refs/output/#analora.output.BaseOutput","title":"analora.output.BaseOutput","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an output.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.output import Output\n&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; output = Output(content=ContentGenerator(\"meow\"), evaluator=Evaluator())\n&gt;&gt;&gt; output\nOutput(\n  (content): ContentGenerator()\n  (evaluator): Evaluator(count=0)\n)\n&gt;&gt;&gt; output.get_content_generator()\nContentGenerator()\n&gt;&gt;&gt; output.get_evaluator()\nEvaluator(count=0)\n</code></pre>"},{"location":"refs/output/#analora.output.BaseOutput.compute","title":"analora.output.BaseOutput.compute  <code>abstractmethod</code>","text":"<pre><code>compute() -&gt; BaseOutput\n</code></pre> <p>Compute the results and return a new ouptut.</p> <p>Returns:</p> Type Description <code>BaseOutput</code> <p>A new ouptut with the computed results.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.output import Output\n&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; output = Output(\n...     content=ContentGenerator(\"meow\"), evaluator=Evaluator({\"accuracy\": 0.42})\n... )\n&gt;&gt;&gt; out = output.compute()\n&gt;&gt;&gt; out\nOutput(\n  (content): ContentGenerator()\n  (evaluator): Evaluator(count=1)\n)\n</code></pre>"},{"location":"refs/output/#analora.output.BaseOutput.equal","title":"analora.output.BaseOutput.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two outputs are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other output to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two outputs are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.output import Output\n&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; output1 = Output(content=ContentGenerator(\"meow\"), evaluator=Evaluator())\n&gt;&gt;&gt; output2 = Output(content=ContentGenerator(\"meow\"), evaluator=Evaluator())\n&gt;&gt;&gt; output3 = Output(\n...     content=ContentGenerator(\"hello\"), evaluator=Evaluator({\"accuracy\": 0.42})\n... )\n&gt;&gt;&gt; output1.equal(output2)\nTrue\n&gt;&gt;&gt; output1.equal(output3)\nFalse\n</code></pre>"},{"location":"refs/output/#analora.output.BaseOutput.get_content_generator","title":"analora.output.BaseOutput.get_content_generator  <code>abstractmethod</code>","text":"<pre><code>get_content_generator(\n    lazy: bool = True,\n) -&gt; BaseContentGenerator\n</code></pre> <p>Get the HTML content generator associated to the output.</p> <p>Parameters:</p> Name Type Description Default <code>lazy</code> <code>bool</code> <p>If <code>True</code>, it forces the computation of the content, otherwise it returns a content generator object that contains the logic to generate the content.</p> <code>True</code> <p>Returns:</p> Type Description <code>BaseContentGenerator</code> <p>The HTML content generator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.output import Output\n&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; output = Output(content=ContentGenerator(\"meow\"), evaluator=Evaluator())\n&gt;&gt;&gt; output.get_content_generator()\nContentGenerator()\n</code></pre>"},{"location":"refs/output/#analora.output.BaseOutput.get_evaluator","title":"analora.output.BaseOutput.get_evaluator  <code>abstractmethod</code>","text":"<pre><code>get_evaluator(lazy: bool = True) -&gt; BaseEvaluator\n</code></pre> <p>Get the evaluator associated to the output.</p> <p>Parameters:</p> Name Type Description Default <code>lazy</code> <code>bool</code> <p>If <code>True</code>, it forces the computation of the metrics, otherwise it returns an evaluator object that contains the logic to evaluate the metrics.</p> <code>True</code> <p>Returns:</p> Type Description <code>BaseEvaluator</code> <p>The evaluator.</p> <p>Example usage:</p> <p>```pycon</p> <p>from analora.output import Output from analora.content import ContentGenerator from analora.evaluator import Evaluator output = Output(content=ContentGenerator(\"meow\"), evaluator=Evaluator()) output.get_evaluator() Evaluator(count=0)</p>"},{"location":"refs/output/#analora.output.EmptyOutput","title":"analora.output.EmptyOutput","text":"<p>               Bases: <code>Output</code></p> <p>Implement the accuracy output.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.output import EmptyOutput\n&gt;&gt;&gt; output = EmptyOutput()\n&gt;&gt;&gt; output\nEmptyOutput()\n&gt;&gt;&gt; output.get_content_generator()\nContentGenerator()\n&gt;&gt;&gt; output.get_evaluator()\nEvaluator(count=0)\n</code></pre>"},{"location":"refs/output/#analora.output.Output","title":"analora.output.Output","text":"<p>               Bases: <code>BaseLazyOutput</code></p> <p>Implement a simple output.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>BaseContentGenerator</code> <p>The HTML content generator.</p> required <code>evaluator</code> <code>BaseEvaluator</code> <p>The evaluator.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from analora.output import Output\n&gt;&gt;&gt; from analora.content import ContentGenerator\n&gt;&gt;&gt; from analora.evaluator import Evaluator\n&gt;&gt;&gt; output = Output(content=ContentGenerator(\"meow\"), evaluator=Evaluator())\n&gt;&gt;&gt; output\nOutput(\n  (content): ContentGenerator()\n  (evaluator): Evaluator(count=0)\n)\n&gt;&gt;&gt; output.get_content_generator()\nContentGenerator()\n&gt;&gt;&gt; output.get_evaluator()\nEvaluator(count=0)\n</code></pre>"},{"location":"refs/plot/","title":"Plot","text":""},{"location":"refs/plot/#analora.plot","title":"analora.plot","text":"<p>Contain plotting functionalities.</p>"},{"location":"refs/plot/#analora.plot.bar_discrete","title":"analora.plot.bar_discrete","text":"<pre><code>bar_discrete(\n    ax: Axes,\n    names: Sequence,\n    counts: Sequence[int],\n    yscale: str = \"auto\",\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>names</code> <code>Sequence</code> <p>The name of the values to plot.</p> required <code>counts</code> <code>Sequence[int]</code> <p>The number of value occurrences.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import bar_discrete\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; bar_discrete(ax, names=[\"a\", \"b\", \"c\", \"d\"], counts=[5, 100, 42, 27])\n</code></pre>"},{"location":"refs/plot/#analora.plot.bar_discrete_temporal","title":"analora.plot.bar_discrete_temporal","text":"<pre><code>bar_discrete_temporal(\n    ax: Axes,\n    counts: ndarray,\n    steps: Sequence | None = None,\n    values: Sequence | None = None,\n    proportion: bool = False,\n) -&gt; None\n</code></pre> <p>Plot the temporal distribution of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>counts</code> <code>ndarray</code> <p>A 2-d array that indicates the number of occurrences for each value and time step. The first dimension represents the value and the second dimension represents the steps.</p> required <code>steps</code> <code>Sequence | None</code> <p>The name associated to each step.</p> <code>None</code> <code>values</code> <code>Sequence | None</code> <p>The name associated to each value.</p> <code>None</code> <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import bar_discrete_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; bar_discrete_temporal(\n...     ax, counts=np.ones((5, 20)), values=list(range(5)), steps=list(range(20))\n... )\n</code></pre>"},{"location":"refs/plot/#analora.plot.binary_precision_recall_curve","title":"analora.plot.binary_precision_recall_curve","text":"<pre><code>binary_precision_recall_curve(\n    ax: Axes,\n    y_true: ndarray,\n    y_pred: ndarray,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Plot the precision-recall curve for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> with <code>0</code> and <code>1</code> values.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> with <code>0</code> and <code>1</code> values.</p> required <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments that are passed to <code>PrecisionRecallDisplay.from_predictions</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import binary_precision_recall_curve\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; binary_precision_recall_curve(\n...     ax=ax, y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n</code></pre>"},{"location":"refs/plot/#analora.plot.binary_roc_curve","title":"analora.plot.binary_roc_curve","text":"<pre><code>binary_roc_curve(\n    ax: Axes,\n    y_true: ndarray,\n    y_score: ndarray,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Plot the Receiver Operating Characteristic Curve (ROC) for binary labels.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code>.</p> required <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments that are passed to <code>RocCurveDisplay.from_predictions</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import binary_roc_curve\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; binary_roc_curve(\n...     ax=ax, y_true=np.array([1, 0, 0, 1, 1]), y_score=np.array([2, -1, 0, 3, 1])\n... )\n</code></pre>"},{"location":"refs/plot/#analora.plot.boxplot_continuous","title":"analora.plot.boxplot_continuous","text":"<pre><code>boxplot_continuous(\n    ax: Axes,\n    array: ndarray,\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import boxplot_continuous\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; boxplot_continuous(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#analora.plot.boxplot_continuous_temporal","title":"analora.plot.boxplot_continuous_temporal","text":"<pre><code>boxplot_continuous_temporal(\n    ax: Axes,\n    data: Sequence[ndarray],\n    steps: Sequence,\n    ymin: float | str | None = None,\n    ymax: float | str | None = None,\n    yscale: str = \"linear\",\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>data</code> <code>Sequence[ndarray]</code> <p>The sequence of data where each item is a 1-d array with the values of the time step.</p> required <code>steps</code> <code>Sequence</code> <p>The sequence time step names.</p> required <code>ymin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>ymax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>data</code> and <code>steps</code> have different lengths</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import boxplot_continuous_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; data = [rng.standard_normal(1000) for _ in range(10)]\n&gt;&gt;&gt; boxplot_continuous_temporal(ax, data=data, steps=list(range(len(data))))\n</code></pre>"},{"location":"refs/plot/#analora.plot.hist_continuous","title":"analora.plot.hist_continuous","text":"<pre><code>hist_continuous(\n    ax: Axes,\n    array: ndarray,\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    cdf: bool = True,\n    quantile: bool = True,\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>cdf</code> <code>bool</code> <p>If <code>True</code>, the CDF is added to the plot.</p> <code>True</code> <code>quantile</code> <code>bool</code> <p>If <code>True</code>, the 5% and 95% quantiles are added to the plot.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import hist_continuous\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; hist_continuous(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#analora.plot.hist_continuous2","title":"analora.plot.hist_continuous2","text":"<pre><code>hist_continuous2(\n    ax: Axes,\n    array1: ndarray,\n    array2: ndarray,\n    label1: str = \"first\",\n    label2: str = \"second\",\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n) -&gt; None\n</code></pre> <p>Plot the histogram of two arrays to compare the distributions.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array1</code> <code>ndarray</code> <p>The first array with the data.</p> required <code>array2</code> <code>ndarray</code> <p>The second array with the data.</p> required <code>label1</code> <code>str</code> <p>The label associated to the first array.</p> <code>'first'</code> <code>label2</code> <code>str</code> <p>The label associated to the second array.</p> <code>'second'</code> <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import hist_continuous2\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; hist_continuous2(ax, array1=np.arange(101), array2=np.arange(51))\n</code></pre>"},{"location":"refs/plot/#analora.plot.plot_cdf","title":"analora.plot.plot_cdf","text":"<pre><code>plot_cdf(\n    ax: Axes,\n    array: ndarray,\n    nbins: int | None = None,\n    xmin: float = float(\"-inf\"),\n    xmax: float = float(\"inf\"),\n    color: str = \"tab:blue\",\n    labelcolor: str = \"black\",\n) -&gt; None\n</code></pre> <p>Plot the cumulative distribution function (CDF).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot the CDF.</p> <code>None</code> <code>xmin</code> <code>float</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>float('-inf')</code> <code>xmax</code> <code>float</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>float('inf')</code> <code>color</code> <code>str</code> <p>The plot color.</p> <code>'tab:blue'</code> <code>labelcolor</code> <code>str</code> <p>The label color.</p> <code>'black'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import plot_cdf\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; plot_cdf(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#analora.plot.plot_null_temporal","title":"analora.plot.plot_null_temporal","text":"<pre><code>plot_null_temporal(\n    ax: Axes,\n    nulls: Sequence,\n    totals: Sequence,\n    labels: Sequence,\n) -&gt; None\n</code></pre> <p>Plot the temporal distribution of the number of missing values.</p> <p><code>nulls</code>, <code>totals</code>, and <code>labels</code> must have the same length and have the same order.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>nulls</code> <code>Sequence</code> <p>The number of null values for each temporal period.</p> required <code>totals</code> <code>Sequence</code> <p>The number of total values for each temporal period.</p> required <code>labels</code> <code>Sequence</code> <p>The labels for each temporal period.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>nulls</code>, <code>totals</code>, and <code>labels</code> have different lengths.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from analora.plot import plot_null_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; plot_null_temporal(\n...     ax, nulls=[1, 2, 3, 4], totals=[10, 12, 14, 16], labels=[\"jan\", \"feb\", \"mar\", \"apr\"]\n... )\n</code></pre>"},{"location":"refs/state/","title":"State","text":""},{"location":"refs/state/#analora.state","title":"analora.state","text":"<p>Contain states.</p>"},{"location":"refs/state/#analora.state.AccuracyState","title":"analora.state.AccuracyState","text":"<p>               Bases: <code>BaseArgState</code></p> <p>Implement a state used to compute accuracy results.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> where the values are in <code>{0, ..., n_classes-1}</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> where the values are in <code>{0, ..., n_classes-1}</code>.</p> required <code>y_true_name</code> <code>str</code> <p>The name associated to the ground truth target labels.</p> required <code>y_pred_name</code> <code>str</code> <p>The name associated to the predicted labels.</p> required <code>nan_policy</code> <code>str</code> <p>The policy on how to handle NaN values in the input arrays. The following options are available: <code>'omit'</code>, <code>'propagate'</code>, and <code>'raise'</code>.</p> <code>'propagate'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.state import AccuracyState\n&gt;&gt;&gt; state = AccuracyState(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_true_name=\"target\",\n...     y_pred_name=\"pred\",\n... )\n&gt;&gt;&gt; state\nAccuracyState(y_true=(5,), y_pred=(5,), y_true_name='target', y_pred_name='pred', nan_policy='propagate')\n</code></pre>"},{"location":"refs/state/#analora.state.BaseState","title":"analora.state.BaseState","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a state.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.state import AccuracyState\n&gt;&gt;&gt; state = AccuracyState(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_true_name=\"target\",\n...     y_pred_name=\"pred\",\n... )\n&gt;&gt;&gt; state\nAccuracyState(y_true=(5,), y_pred=(5,), y_true_name='target', y_pred_name='pred', nan_policy='propagate')\n</code></pre>"},{"location":"refs/state/#analora.state.BaseState.clone","title":"analora.state.BaseState.clone  <code>abstractmethod</code>","text":"<pre><code>clone(deep: bool = True) -&gt; Self\n</code></pre> <p>Return a copy of the state.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If <code>True</code>, it returns a deep copy of the state, otherwise it returns a shallow copy.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the state.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.state import AccuracyState\n&gt;&gt;&gt; state = AccuracyState(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_true_name=\"target\",\n...     y_pred_name=\"pred\",\n... )\n... cloned_state = state.clone()\n</code></pre>"},{"location":"refs/state/#analora.state.BaseState.equal","title":"analora.state.BaseState.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two states are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other state to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two states are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from analora.state import AccuracyState\n&gt;&gt;&gt; state1 = AccuracyState(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_true_name=\"target\",\n...     y_pred_name=\"pred\",\n... )\n&gt;&gt;&gt; state2 = AccuracyState(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_true_name=\"target\",\n...     y_pred_name=\"pred\",\n... )\n&gt;&gt;&gt; state3 = AccuracyState(\n...     y_true=np.array([1, 0, 0, 0, 0]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_true_name=\"target\",\n...     y_pred_name=\"pred\",\n... )\n&gt;&gt;&gt; state1.equal(state2)\nTrue\n&gt;&gt;&gt; state1.equal(state3)\nFalse\n</code></pre>"}]}